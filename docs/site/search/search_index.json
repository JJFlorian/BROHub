{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introductie","text":""},{"location":"#welkom-op-de-brostar-documentatie","title":"Welkom op de BROSTAR documentatie!","text":"<p>De BROSTAR is een applicatie die is ontwikkeld door Nelen &amp; Schuurmans om het aanleverproces van data naar de Basis Registratie Ondergrond (BRO) aanzienlijk makkelijker te maken.</p> <p>Het aanleveren van data naar de BRO is een technisch process, waarbij kennis van o.a. XML bestanden, scripting en API's vereist is bij de leverancier. Daarom wordt dit proces vaak uitbesteed vanuit de brondhouders. In de praktijk bleek dat hierbij de mate van maatwerk enorm hoog was in verband met eigen manieren van dataopslag, datamodellen, applicaties en data governance. De BROSTAR is een applicatie die door elke organisatie op meerdere manieren ingezet kan worden.</p> <p>De BROSTAR bestaat uit een open-source API en een closed-source frontend.</p>"},{"location":"#api","title":"API","text":"<p>Note</p> <p>Klik hier voor de technische documentatie van de BROSTAR API.</p> <p>De basis van de BROSTAR is de API. De API heeft 2 belangrijke hoofdfunctionaliteiten:</p> <ul> <li> <p>Import taken:</p> <p>Het is mogelijk om data vanuit de BRO te importeren in de database van de BROSTAR. Het gaat hierbij alleen om metadata van de objecten, en niet van de gehele geschiedenis. In de filosofie van de BROSTAR is de BRO zelf de waarheid en altijd het meest up-to-date. Na een import is het mogelijk om deze gegevens op te vragen en in te zien.</p> <p>Note</p> <p>Het is mogelijk om openbare data van andere organisaties vanuit de BRO te importeren</p> </li> <li> <p>Upload taken:</p> <p>Met behulp van upload taken kan data naar de BRO worden gestuurd. Alle mogelijke berichten worden ondersteund vanuit de API. Het idee van deze functionaliteit is dat je als scripter slechts 1 stap hoeft uit te voeren: het opstellen van een JSON met daarin alle relevante informatie voor het specifieke bericht dat opgestuurd moet worden. Nadat deze als request naar de BROSTAR wordt opgestuurd, wordt de rest afgehandeld. Dit omvat het opstellen van een XML bestand, de validatie, de daadwerkelijke levering, en de voortgang van de levering. De voortgang wordt als status bijgehouden, met eventueel belangrijke logging vanuit de BRO.</p> </li> </ul> <p>De API van de BROSTAR is dus een krachtig hulpmiddel bij zowel managen van bestaande data in de BRO als het aanleveren van de data. Door de BROSTAR te gebruiken wordt een groot deel van het aanleverprocess afgevangen en kan er relatief makkelijk een scripting connectie met de BRO gemaakt worden.</p>"},{"location":"#frontend","title":"Frontend","text":"<p>Note</p> <p>Klik hier voor een uitgebreidere functionele documentatie van de frontend.</p> <p>De frontend is de visuele versie van de BROSTAR. Deze is ontwikkeld zodat ook personen zonder scripting ervaring laagdrempelig data kunnen aanleveren. Dit maakt het mogelijk voor bronhouders om het databeheer zelf in handen te houden.</p> <p>Als organisatie heb je een eigen omgeving, en kun je eigen data importeren. Net zoals in de API is het ook mogelijk om data van andere organisaties te importeren. Deze data is op een kaart of in een tabel in te zien, en voor sommige type objecten zelfs al gemakkelijk aan te passen:</p> <p> BROSTAR homepagina (voorbeeld: Provincie Gelderland)</p> <p>Het aanleveren van data via de frontend gebeurt achter de schermen via de API. Na het eenmalig instellen van aanlevertokens voor de BRO, is het als gebruiker is het mogelijk om gebruiksvriendelijke formulieren in te vullen of om Excel bestanden aan te leveren voor bulk uploads. Hieronder is een voorbeeld te zien waarin startregistratie van een GMN geregeld kan worden via een invulformulier. Als gebruiker kun je bovenin metadata van het GMN invullen. Onderin kunnen GMW's op de kaart geselecteerd worden, om vervolgens de relevante buizen te selecteren die als Meetpunt aangeleverd worden.</p> <p> GMN startregistratie invulformulier</p> <p>Nadat een levering is gedaan, is het mogelijk om de status ervan in te zien. Als een levering niet geslaagd is, kunnen de foutmeldingen vanuit de BRO ingezien worden, om vervolgens de levering aan te passen. Hiermee wordt de gebruiker terug gestuurd naar het ingevulde formulier, waardoor een aanpassing gemakkelijk gemaakt kan worden voordat een nieuwe poging tot levering gedaan kan worden:</p> <p> Voorbeeld van de foutmeldingen bij een gefaalde taak. Op de achtergrond zijn succesvolle taken te zien.</p> <p>Note</p> <p>De frontend is nog vol in ontwikkeling. Momenteel zijn de type berichten die mogelijk zijn vanuit de frontend beperkt. Als er vanuit meerdere gebruikers wensen tot uitbreiding zijn, worden deze gerealiseerd.</p>"},{"location":"#productie-vs-demo","title":"Productie vs Demo","text":"<p>Net zoals de BRO zelf, heeft de BROSTAR een productie en een staging omgeving. De productie van de BROSTAR is op de productie van de BRO gekoppeld en de staging is op de demo van de BRO gekoppeld.</p> <p>Als je als organisatie een licensie op de BROSTAR neemt, krijg je een eigen omgeving op beide versies. Daarmee is het mogelijk om eerst te testen en te ontwikkelen met dummy data via de demo omgeving.</p>"},{"location":"#interesse","title":"Interesse?","text":"<p>Heb je interesse om een demo van de BROSTAR te krijgen of om tijdelijk op de staging omgeving te testen? Contact info@nelen-schuurmans.com</p>"},{"location":"api/","title":"API","text":"<p>De browsable BROSTAR API is te vinden op https://www.brostar.nl/api/ of op https://www.staging.brostar.nl/api/</p>"},{"location":"api/#api-keys","title":"API Keys","text":"<p>Voor elke request die op de API gedaan wordt, moet een API key gebruikt worden om de gebruiker te authenticeren. Een API key is gebruikersgebonden en kunnen momenteel alleen aangevraagd worden bij Nelen &amp; Schuurmans. Het eigenhandig beheren van API keys in de Api en frontend zal spoedig worden ontwikkeld.</p> <p>Een request op de BROSTAR API, inclusief een API Key, ziet er als volgt uit:</p> <pre><code>import requests\nfrom requests.auth import HTTPBasicAuth\n\nBROSTAR_API_KEY = ... # Verberg altijd je API Key!\n\nauth = HTTPBasicAuth(\n    username=\"__key__\",\n    password=BROSTAR_API_KEY,\n)\n\nurl = \"https://www.brostar.nl/api/\"\n\nr = requests.get(url, auth=auth)\n</code></pre> <p>Note</p> <p>De username in de basic authenticatie is altijd <code>__key__</code></p>"},{"location":"api/#endpoints","title":"Endpoints","text":"<p>De API bestaat uit de volgende endpoints:</p> <p>Authenticatie en authorisatie endpoints:</p> <ul> <li> <p>Organisations</p> </li> <li> <p>Users</p> </li> </ul> <p>Functionele endpoints:</p> <ul> <li> <p>Importtasks</p> </li> <li> <p>Uploadtasks</p> </li> <li> <p>Bulk uploadtasks</p> </li> </ul> <p>Data endpoints:</p> <ul> <li> <p>GMNs</p> </li> <li> <p>Measuringpoints</p> </li> <li> <p>GMWs</p> </li> <li> <p>Monitoringtubes</p> </li> <li> <p>GARs</p> </li> <li> <p>GLDs</p> </li> <li> <p>FRDs</p> </li> </ul>"},{"location":"api/#organisations","title":"Organisations","text":"<p>Note</p> <p>Organisaties kunnen alleen aangemaakt worden door medewerkers van Nelen &amp; Schuurmans. Staat jouw organisatie nog niet geregistreerd? Contact info@nelen-schuurmans.com</p> <p>Organisaties zijn de basis van het datamodel van de BROSTAR. Elke gebruiker, maar ook elk data object zoals geimporteerde data vanuit de BRO, valt onder een organisatie. Als gebruiker zie je dus alleen de data die onder jouw organisatie valt.</p> <p>Een organisatie bestaat uit een combinatie van een naam en een kvk nummer. Als je als gebruiker een import taak start, zonder specifiek een kvk nummer op te geven, wordt altijd het kvk nummer van de organisatie waar je onder valt gebruikt in de communicatie naar de BRO. Het is echter mogelijk om een ander kvk nummer op te geven, waarmee je openbare data van andere organisaties kan importeren.</p> <p>Om het opzoeken van kvk nummers makkelijker te maken, is het mogelijk om alle geregistreerde organisaties in de BROSTAR, inclusief kvk nummer, in te zien. Deze zijn in te zien op het https://www.brostar.nl/api/organisations/ endpoint.</p> <p>Warning</p> <p>Om de data in de browsable in te kunnen zien moet een gebruiker ingelogd zijn.</p>"},{"location":"api/#users","title":"Users","text":"<p>Elke gebruiker krijgt een eigen account op basis van een email adres. Vooralsnog vindt het gebruikersmanagement via Nelen &amp; Schuurmans plaats. Later wordt dit eventueel vergemakkelijkt en in handen van de admins van een organisatie gegeven.</p> <p>Elk account hangt onder een organisatie.</p> <p>Op het https://www.brostar.nl/api/users/logged-in/ kunnen user-gegevens ingezien worden.</p>"},{"location":"api/#importtasks","title":"Importtasks","text":"<p>Import taken zorgen ervoor dat de huidig aanwezige data in de BRO in de BROSTAR database belanden. Deze data is vervolgens in de specifieke endpoints op te vragen.</p> <p>Import taken vinden plaats op basis van POST requests. In deze request wordt een combinatie van een BRO domein (GAR, GLD, GMW, GMN of FRD) en een kvk nummer meegegeven. Voordat de import start, wordt alle data voor dat domein in de BROSTAR verwijderd. Nadat een taak is geslaagd, is de data in de BROSTAR voor dat specifieke domein dus up-to-date met de BRO.</p> <p>De data die wordt geimporteerd is slechts de huidige versie van de metadata. Er wordt dus bijvoorbeeld geen geschiedenis van een GMW of de standen van een GLD geimporteerd. Hiervoor kan de BRO zelf bevraagd worden.</p> <p>Note</p> <p>De aanwezigheid van de data in de BROSTAR is essentieel voor de frontend om te bestaan. Het kan dus zijn dat je als scripter, die alleen bezig is met het aanleveren van data, geen gebruik maakt van dit endpoint. Toch kan het in sommige gevallen handig zijn. Voorbeelden hiervan zijn om een vertaling van een nitg code naar een BRO id te maken of te controleren of bepaalde objecten reeds aangeleverd zijn.</p> <p>Hieronder een voorbeeld van een POST request om een GMN import taak voor eigen organisatie te starten:</p> <pre><code>import requests\nfrom requests.auth import HTTPBasicAuth\n\nBROSTAR_API_KEY = ...\n\nauth = HTTPBasicAuth(\n    username=\"__key__\",\n    password=BROSTAR_API_KEY,\n)\n\nurl = \"https://www.brostar.nl/api/importtasks/  \"\n\npayload = {\n    \"bro_domain\": \"GMN\"\n}\n\nr = requests.post(url, auth=auth, payload=payload)\n</code></pre>"},{"location":"api/#uploadtasks","title":"Uploadtasks","text":"<p>Upload taken zijn d\u00e9 kracht van de BROSTAR. Het idee achter dit endpoint is dat er slechts JSON opgesteld hoeft te worden om data aan te leveren. Om dit te visualiseren volgt hieronder een code snippet, waarmee een GMN aangemaakt kan worden in de BRO.</p> <pre><code>import requests\nfrom requests.auth import HTTPBasicAuth\n\nBROSTAR_API_KEY = ...\n\nauth = HTTPBasicAuth(\n    username=\"__key__\",\n    password=BROSTAR_API_KEY,\n)\n\nurl = \"https://www.brostar.nl/api/importtasks/  \"\n\nmetadata = {\n    \"requestReference\":\"test\",\n    \"deliveryAccountableParty\":\"12345678\",\n    \"qualityRegime\":\"IMBRO\"\n}\n\nsourcedocument_data = {\n    \"objectIdAccountableParty\":\"test\",\n    \"name\":\"test\",\n    \"deliveryContext\":\"kaderrichtlijnWater\",\n    \"monitoringPurpose\":\"strategischBeheerKwaliteitRegionaal\",\n    \"groundwaterAspect\":\"kwantiteit\",\n    \"startDateMonitoring\":\"2024-01-01\",\n    \"measuringPoints\":[\n        {\n        \"measuringPointCode\":\"PUT00001\",\n        \"broId\":\"GMW000000000001\",\n        \"tubeNumber\":\"1\"\n        }\n    ]\n}\n\npayload = {\n    \"bro_domain\": \"GMN\",\n    \"project_number\": \"1234\",\n    \"registration_type\": \"GMN_StartRegistration\",\n    \"request_type\": \"registration\",\n    \"metadata\": metadata,\n    \"sourcedocument_data\": sourcedocument_data\n}\n\n\nr = requests.post(url, auth=auth, payload=payload)\n</code></pre> <p>De BROSTAR API zal een taak starten waarin 1) een XML bestand wordt aangemaakt, 2) het bestand wordt gevalideerd bij de BRO, 3) het bestand wordt aangeleverd en 4) de voortgang wordt gecontroleerd. De status hiervan wordt bijgehouden in de instantie van de upload taak. Voor elke uploadtaak kan men de volgende eigenschappen inzien om de status bij te houden:</p> <p></p> <p>In een post request bestaat de payload uit 6 belangrijke onderdelen:</p>"},{"location":"api/#bro_domain","title":"bro_domain","text":"<p>Het BRO domein bepaalt voor welk type object (GAR, GLD, GMW, GMN of FRD) de data aangeleverd wordt.</p>"},{"location":"api/#project_number","title":"project_number","text":"<p>Het BRO project nummer is nodig om data bij de BRO aan te kunnen leveren. Deze kun je in het Bronhouderportaal aanvragen/vinden.</p>"},{"location":"api/#registration_type","title":"registration_type","text":"<p>Voor elk BRO domein zijn er verschillende type berichten mogelijk. Zo zijn er bijvoorbeeld voor de GMN Startregistration, MeasuringPoint, en Closure als berichten mogelijk.</p>"},{"location":"api/#request_type","title":"request_type","text":"<p>Elk registratie type kan op verschillende manieren aangeleverd worden. In principe is de registration de standaardoptie, maar als er data aangepast of verwijderd moet worden, dan zijn respectievelijk de replace en delete requests types beschikbaar. In de BRO catalogus staan alle mogelijke combinaties. Dit zijn de beschikbare request types:</p> <ul> <li> <p>registration</p> </li> <li> <p>replace</p> </li> <li> <p>move</p> </li> <li> <p>insert</p> </li> <li> <p>delete</p> </li> </ul>"},{"location":"api/#metadata","title":"metadata","text":"<p>Voor elke combinatie van registration type en request type wordt achter de schermen een XML bestand opgesteld worden (zie voorbeeld startregistratie GMN). Elk XML bestand begint met metadata, die voor alle berichten hetzelfde zijn. De enige variatie hierin is welke combinatie van waardes meegegeven moet worden. De BROSTAR API ontvangt de metadata JSON en valideert deze met het volgende Pydantic model:</p> <pre><code>from pydantic import BaseModel\n\nclass UploadTaskMetadata(BaseModel):\n    requestReference: str\n    deliveryAccountableParty: str | None = None\n    qualityRegime: str\n    broId: str | None = None\n    underPrivilege: str | None = None\n    correctionReason: str | None = None\n    dateToBeCorrected: str | date | None = None\n</code></pre> <p>Elke metadata moet dus minimaal bestaan uit een requestReference en qualityRegime. Afhankelijk van de combinatie van de registration type en de request type kunnen ook andere benodigd zijn. Om een idee te krijgen van welke data er verwacht wordt, kunnen de XML templates van de BROSTAR gebruikt worden. Deze worden door de API gebruikt om de XML bestanden op te stellen, en zijn daarmee de voorbeelden van welke data er in de metadata wordt verwacht.</p>"},{"location":"api/#sourcedocument_data","title":"sourcedocument_data","text":"<p>De sourcedocument data is de data die benodigd is om de specifieke XML bestanden op te stellen voor elke combinatie van de registration type en de request type. Deze kunnen dus enorm verschillen.</p> <p>Net zoals de metadata, wordt de sourcedocument data door de API gevalideerd met behulp van Pydantic models.</p> <p>Tip</p> <p>Voor simpele eenmalige leveringen kunnen deze worden gebruikt om een JSON samen te stellen. Voor grotere, complexere of operationele leveringen, wordt het aangeraden om de Pydantic models te kopieren in de eigen code.</p>"},{"location":"api/#gmn-startregistratie","title":"GMN Startregistratie","text":"<pre><code>from pydantic import BaseModel\n\nclass GMNStartregistration(BaseModel):\n    objectIdAccountableParty: str\n    name: str\n    deliveryContext: str\n    monitoringPurpose: str\n    groundwaterAspect: str\n    startDateMonitoring: str\n    measuringPoints: list[MeasuringPoint]\n\nclass MeasuringPoint(BaseModel):\n    measuringPointCode: str\n    broId: str\n    tubeNumber: str | int\n</code></pre>"},{"location":"api/#gmn-measuringpoint","title":"GMN MeasuringPoint","text":"<pre><code>from pydantic import BaseModel\n\nclass GMNMeasuringPoint(BaseModel):\n    eventDate: str\n    measuringPointCode: str\n    broId: str\n    tubeNumber: str | int\n</code></pre>"},{"location":"api/#gmn-measuringpointenddate","title":"GMN MeasuringPointEndDate","text":"<pre><code>from pydantic import BaseModel\n\nclass GMNMeasuringPointEndDate(BaseModel):\n    eventDate: str\n    measuringPointCode: str\n    broId: str\n    tubeNumber: str | int\n</code></pre>"},{"location":"api/#gmn-tubereference","title":"GMN TubeReference","text":"<pre><code>from pydantic import BaseModel\n\nclass GMNTubeReference(BaseModel):\n    eventDate: str\n    measuringPointCode: str\n</code></pre>"},{"location":"api/#gmn-closure","title":"GMN Closure","text":"<pre><code>from pydantic import BaseModel\n\n\nclass GMNClosure(BaseModel):\n    endDateMonitoring: str\n</code></pre>"},{"location":"api/#gwm-gmwconstruction","title":"GWM GMWConstruction","text":"<pre><code>from pydantic import BaseModel\n\nclass GMWConstruction(BaseModel):\n    objectIdAccountableParty: str\n    deliveryContext: str\n    constructionStandard: str\n    initialFunction: str\n    numberOfMonitoringTubes: str | int\n    groundLevelStable: str\n    wellStability: str | None = None\n    owner: str\n    maintenanceResponsibleParty: str\n    wellHeadProtector: str\n    wellConstructionDate: str\n    deliveredLocation: str\n    horizontalPositioningMethod: str\n    localVerticalReferencePoint: str\n    offset: str | float\n    verticalDatum: str\n    groundLevelPosition: str | float | None = None\n    groundLevelPositioningMethod: str\n    monitoringTubes: list[MonitoringTube]\n\nclass MonitoringTube(BaseModel):\n    tubeNumber: str | int\n    tubeType: str\n    artesianWellCapPresent: str\n    sedimentSumpPresent: str\n    numberOfGeoOhmCables: str | int\n    tubeTopDiameter: str | float | None = None\n    variableDiameter: str | float\n    tubeStatus: str\n    tubeTopPosition: str | float\n    tubeTopPositioningMethod: str\n    tubePackingMaterial: str\n    tubeMaterial: str\n    glue: str\n    screenLength: str | float\n    sockMaterial: str\n    plainTubePartLength: str | float\n    sedimentSumpLength: str | float | None = None\n    geoohmcables: list[GeoOhmCable] | None = None\n\nclass GeoOhmCable(BaseModel):\n    cableNumber: str | int\n    electrodes: list[Electrode]\n\nclass Electrode(BaseModel):\n    electrodeNumber: str | int\n    electrodePackingMaterial: str\n    electrodeStatus: str\n    electrodePosition: str | float\n</code></pre>"},{"location":"api/#gmw-events","title":"GMW Events","text":"<pre><code>from pydantic import BaseModel\n\nclass GMWEvent(BaseModel):\n    eventDate: str\n\n\nclass GMWElectrodeStatus(GMWEvent):\n    electrodes: list[Electrode]\n\n\nclass GMWGroundLevel(GMWEvent):\n    wellStability: str | None = None\n    groundLevelStable: str\n    groundLevelPosition: str\n    groundLevelPositioningMethod: str\n\n\nclass GMWGroundLevelMeasuring(GMWEvent):\n    groundLevelPosition: str\n    groundLevelPositioningMethod: str\n\n\nclass GMWInsertion(GMWEvent):\n    tubeNumber: str\n    tubeTopPosition: str\n    tubeTopPositioningMethod: str\n    insertedPartLength: str\n    insertedPartDiameter: str\n    insertedPartMaterial: str\n\n\nclass MonitoringTubeLengthening(BaseModel):\n    tubeNumber: str | int\n    variableDiameter: str | float\n    tubeTopPosition: str | float\n    tubeTopPositioningMethod: str\n    tubeMaterial: str\n    glue: str\n    plainTubePartLength: str | float\n\n\nclass GMWLengthening(GMWEvent):\n    wellHeadProtector: str | None = None\n    monitoringTubes: list[MonitoringTubeLengthening]\n\n\nclass GMWMaintainer(GMWEvent):\n    maintenanceResponsibleParty: str\n\n\nclass GMWOwner(GMWEvent):\n    owner: str\n\n\nclass MonitoringTubePositions(BaseModel):\n    tubeNumber: str | int\n    tubeTopPosition: str | float\n    tubeTopPositioningMethod: str\n\n\nclass GMWPositions(GMWEvent):\n    wellStability: str | None = None\n    groundLevelStable: str\n    groundLevelPosition: str\n    groundLevelPositioningMethod: str\n    monitoringTubes: list[MonitoringTubePositions]\n\n\nclass GMWPositionsMeasuring(GMWEvent):\n    monitoringTubes: list[MonitoringTube]\n    groundLevelPosition: str | None = None\n    groundLevelPositioningMethod: str | None = None\n\n\nclass GMWRemoval(GMWEvent):\n    pass\n\n\nclass GMWShift(GMWEvent):\n    groundLevelPosition: str\n    groundLevelPositioningMethod: str\n\n\nclass MonitoringTubeShortening(BaseModel):\n    tubeNumber: str | int\n    tubeTopPosition: str | float\n    tubeTopPositioningMethod: str\n    plainTubePartLength: str | float\n\n\nclass GMWShortening(GMWEvent):\n    wellHeadProtector: str | None = None\n    monitoringTubes: list[MonitoringTubeShortening]\n\n\nclass MonitoringTubeStatus(BaseModel):\n    tubeNumber: str | int\n    tubeStatus: str\n\n\nclass GMWTubeStatus(GMWEvent):\n    monitoringTubes: list[MonitoringTubeStatus]\n\n\nclass GMWWellHeadProtector(GMWEvent):\n    wellHeadProtector: str\n</code></pre>"},{"location":"api/#gar-startregistration","title":"GAR StartRegistration","text":"<pre><code>from pydantic import BaseModel\n\nclass GAR(BaseModel):\n    objectIdAccountableParty: str\n    qualityControlMethod: str\n    groundwaterMonitoringNets: list[str] | None = None\n    gmwBroId: str\n    tubeNumber: str | int\n    fieldResearch: FieldResearch\n    laboratoryAnalyses: list[LaboratoryAnalysis] | None = None\n\n\nclass LaboratoryAnalysis(BaseModel):\n    responsibleLaboratoryKvk: str | None = None\n    analysisProcesses: list[AnalysisProcess] = []\n\nclass AnalysisProcess(BaseModel):\n    date: str | date\n    analyticalTechnique: str\n    valuationMethod: str\n    analyses: list[Analysis]\n\nclass Analysis(BaseModel):\n    parameter: str | int\n    unit: str\n    analysisMeasurementValue: str | float\n    limitSymbol: str | None = None\n    reportingLimit: str | float | None = None\n    qualityControlStatus: str\n\nclass FieldResearch(BaseModel):\n    samplingDateTime: str | datetime\n    samplingOperator: str | None = None\n    samplingStandard: str\n    pumpType: str\n    primaryColour: str | None = None\n    secondaryColour: str | None = None\n    colourStrength: str | None = None\n    abnormalityInCooling: str\n    abnormalityInDevice: str\n    pollutedByEngine: str\n    filterAerated: str\n    groundWaterLevelDroppedTooMuch: str\n    abnormalFilter: str\n    sampleAerated: str\n    hoseReused: str\n    temperatureDifficultToMeasure: str\n    fieldMeasurements: list[FieldMeasurement] | None = None\n\nclass FieldMeasurement(BaseModel):\n    parameter: str | int\n    unit: str\n    fieldMeasurementValue: str | float\n    qualityControlStatus: str\n</code></pre>"},{"location":"api/#gld-startregistration","title":"GLD StartRegistration","text":"<pre><code>from pydantic import BaseModel\n\nclass GLDStartregistration(BaseModel):\n    objectIdAccountableParty: str | None = None\n    groundwaterMonitoringNets: list[str] | None = None\n    gmwBroId: str\n    tubeNumber: str | int\n</code></pre>"},{"location":"api/#gld-addition","title":"GLD Addition","text":"<pre><code>from pydantic import BaseModel\n\nclass GLDAddition(BaseModel):\n    date: str\n    observationId: str | None = None\n    observationProcessId: str | None = None\n    measurementTimeseriesId: str | None = None\n    investigatorKvk: str\n    observationType: str\n    beginPosition: str\n    endPosition: str\n    resultTime: str\n    evaluationProcedure: str\n    measurementInstrumentType: str\n    timeValuePairs: list[TimeValuePair]\n\nclass TimeValuePair(BaseModel):\n    time: str | datetime\n    value: float | str\n    statusQualityControl: str\n</code></pre>"},{"location":"api/#frd-startregistration","title":"FRD StartRegistration","text":"<pre><code>from pydantic import BaseModel\n</code></pre>"},{"location":"api/#frd-startregistration_1","title":"FRD StartRegistration","text":"<pre><code>from pydantic import BaseModel\n\nclass FRDStartRegistration(BaseModel):\n    objectIdAccountableParty: str | None = None\n    groundwaterMonitoringNets: list[str] | None = None\n    gmwBroId: str\n    tubeNumber: str | int\n</code></pre>"},{"location":"api/#frd-measurementconfiguration","title":"FRD MeasurementConfiguration","text":"<pre><code>from pydantic import BaseModel\n\nclass FRDGemMeasurementConfiguration(BaseModel):\n    measurementConfigurations: list[MeasurementConfiguration]\n\nclass MeasurementConfiguration(BaseModel):\n    measurementConfigurationID: str\n    measurementE1CableNumber: str | int\n    measurementE1ElectrodeNumber: str | int\n    measurementE2CableNumber: str | int\n    measurementE2ElectrodeNumber: str | int\n    currentE1CableNumber: str | int\n    currentE1ElectrodeNumber: str | int\n    currentE2CableNumber: str | int\n    currentE2ElectrodeNumber: str | int\n</code></pre>"},{"location":"api/#frd-emminstrumentconfiguration","title":"FRD EmmInstrumentConfiguration","text":"<pre><code>from pydantic import BaseModel\n\nclass FRDEmmInstrumentConfiguration(BaseModel):\n    instrumentConfigurationID: str\n    relativePositionTransmitterCoil: str | int\n    relativePositionPrimaryReceiverCoil: str | int\n    secondaryReceiverCoilAvailable: str\n    relativePositionSecondaryReceiverCoil: str | int | None = None\n    coilFrequencyKnown: str\n    coilFrequency: str | int | None = None\n    instrumentLength: str | int\n</code></pre>"},{"location":"api/#frd-emmmeasurement","title":"FRD EmmMeasurement","text":"<pre><code>from pydantic import BaseModel\n\nclass FRDEmmMeasurement(BaseModel):\n    measurementDate: date | str\n    measurementOperatorKvk: str\n    determinationProcedure: str\n    measurementEvaluationProcedure: str\n    measurementSeriesCount: str | int\n    measurementSeriesValues: str\n    relatedInstrumentConfigurationId: str\n    calculationOperatorKvk: str\n    calculationEvaluationProcedure: str\n    calculationCount: str | int\n    calculationValues: str\n</code></pre>"},{"location":"api/#frd-gemmeasurement","title":"FRD GemMeasurement","text":"<pre><code>from pydantic import BaseModel\n\nclass FRDGemMeasurement(BaseModel):\n    measurementDate: str | date\n    measurementOperatorKvk: str\n    determinationProcedure: str\n    evaluationProcedure: str\n    measurements: list[GemMeasurement]\n    relatedCalculatedApparentFormationResistance: RelatedCalculatedApparentFormationResistance | None = None\n\nclass RelatedCalculatedApparentFormationResistance(BaseModel):\n    calculationOperatorKvk: str\n    evaluationProcedure: str\n    elementCount: str | int\n    values: str\n\nclass GemMeasurement(BaseModel):\n    value: str | int\n    unit: str\n    configuration: str\n</code></pre> <p>TODO: schrijf docs over check status actions endpoint voor uploadtask instanties. (Als een taak op unfinished staat checkt deze opnieuw de status bij de BRO en updatet evt de status van de upload taak)</p> <p>TODO: schrijf over xml endpoint</p>"},{"location":"api/#bulk-uploadtasks","title":"Bulk uploadtasks","text":"<p>TODO</p>"},{"location":"api/#gmns","title":"GMNs","text":"<p>TODO</p>"},{"location":"api/#measuringpoints","title":"Measuringpoints","text":"<p>TODO</p>"},{"location":"api/#gmws","title":"GMWs","text":"<p>TODO</p>"},{"location":"api/#monitoringtubes","title":"Monitoringtubes","text":"<p>TODO</p>"},{"location":"api/#gars","title":"GARs","text":"<p>TODO</p>"},{"location":"api/#glds","title":"GLDs","text":"<p>TODO</p>"},{"location":"api/#frds","title":"FRDs","text":"<p>TODO</p>"},{"location":"frontend/","title":"Frontend","text":""},{"location":"frontend/#todo-schrijven-functionele-documentatie-frontends","title":"Todo: Schrijven functionele documentatie frontends","text":""}]}
